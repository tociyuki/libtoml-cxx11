#!/usr/bin/env ruby

# Toy LALR(1) Parser https://github.com/tociyuki/rzubr-ruby
require 'rzubr'

def grammar_table
  rule = Rzubr::Rule

  toml = rule.name(:toml) \
    > rule[:statements, :sections] \
    | rule[:statements] \
    | rule[:sections] \
    | rule[]

  sections = rule.name(:sections) \
    > rule[:sections, '[', :keypath, ']', :ENDLINE, :statements] \
    | rule[:sections, '[', :keypath, ']', :ENDLINE] \
    | rule[:sections, '[','[', :keypath, ']',']', :ENDLINE, :statements] \
    | rule[:sections, '[','[', :keypath, ']',']', :ENDLINE] \
    | rule['[', :keypath, ']', :ENDLINE, :statements] \
    | rule['[', :keypath, ']', :ENDLINE] \
    | rule['[','[', :keypath, ']',']', :ENDLINE, :statements] \
    | rule['[','[', :keypath, ']',']', :ENDLINE]

  keypath = rule.name(:keypath) \
    > rule[:keypath, '.', :key] \
    | rule[:key]

  key = rule.name(:key) \
    > rule[:BAREKEY] \
    | rule[:STRKEY]

  statements = rule.name(:statements) \
    > rule[:statements, :pair, :ENDLINE] \
    | rule[:pair, :ENDLINE]

  pair = rule.name(:pair) \
    > rule[:key, '=', :value]

  value = rule.name(:value) \
    > rule[:BOOLEAN] \
    | rule[:FIXNUM] \
    | rule[:FLONUM] \
    | rule[:DATETIME] \
    | rule[:STRING] \
    | rule[:STRKEY] \
    | rule['[', :array, ']'] \
    | rule['{', :table, '}'] 

  array = rule.name(:array) \
    > rule[:endln] \
    | rule[:value_list] \
    | rule[:value_list, ',', :endln]

  value_list = rule.name(:value_list) \
    > rule[:endln, :value, :endln] \
    | rule[:value_list, ',', :endln, :value, :endln]

  endln = rule.name(:endln) \
    > rule[] \
    | rule[:ENDLINE]

  table = rule.name(:table) \
    > rule[] \
    | rule[:pair_list]  \
    | rule[:pair_list, ',']

  pair_list = rule.name(:pair_list) \
    > rule[:pair] \
    | rule[:pair_list, ',', :pair]

  g = (toml \
       + sections + keypath + key \
       + statements + value \
       + array + value_list + endln \
       + table + pair_list + pair 
      ).start(:toml)
  Rzubr::LALR1.new.rule(g)
end

def cxxtable(lr)
  token = {
    # nil, 'TOKEN_INVALID',
    :BAREKEY  => 'TOKEN_BAREKEY',
    :STRKEY   => 'TOKEN_STRKEY',
    :STRING   => 'TOKEN_STRING',
    :BOOLEAN  => 'TOKEN_BOOLEAN',
    :FIXNUM   => 'TOKEN_FIXNUM',
    :FLONUM   => 'TOKEN_FLONUM',
    :DATETIME => 'TOKEN_DATETIME',
    '{' => 'TOKEN_LBRACE',
    '}' => 'TOKEN_RBRACE',
    '[' => 'TOKEN_LBRACKET',
    ']' => 'TOKEN_RBRACKET',
    '.' => 'TOKEN_DOT',
    '=' => 'TOKEN_EQUAL',
    ',' => 'TOKEN_COMMA',
    :ENDLINE => 'TOKEN_ENDLINE',
    Rzubr::ENDMARK => 'TOKEN_ENDMARK',
  }
  pnum = {}.tap{|h| lr.production.each_with_index{|e,x| h[e] = 256 - x - 2 } }
  colgoto = lr.production.map{|e| e.lhs }.uniq
  t = ''
  t << '// autogenerated by rzubr' << "\n"
  lr.production.each_with_index do |e, x|
    rhs = e.rhs.map {|s| Symbol === s ? s.to_s : s.inspect }.join(' ')
    t << "//case %2d: // %s: %s" % [x, e.lhs.to_s, rhs] << "\n"
  end
  t << "\n"
  t << '    void' << "\n"
  t << '    define_state ()' << "\n"
  t << '    {' << "\n"
  t << '        enum { ';
  t << '%s = %d, ' % [colgoto[0].to_s, token.size + 1]
  t << colgoto[1 .. -1].map{|x| x.to_s }.join(', ')
  t << ' };' << "\n"
  t << "\n"
  lr.state.term.each_index do |state_p|
    lr.action[state_p].each_pair do |s, x|
      name = token[s] || 'TOKEN_INVALID'
      case x
      when Integer
        t << '        to (%d, %s, %d);' % [state_p + 1, name, x + 1] << "\n"
      when :accept
        t << '        to (%d, %s, 255);' % [state_p + 1, name] << "\n"
      when Rzubr::Production
        t << '        to (%d, %s, %d);' % [state_p + 1, name, pnum[x]] << "\n"
      end
    end
    lr.goto[state_p].each_pair do |s, x|
      t <<   '        to (%d, %s, %d);' % [state_p + 1, s.to_s, x + 1] << "\n"
    end
    t << "\n"
  end
  t << '        nrhs.assign ({'
  t << lr.production.map{|e| e.rhs.size }.join(', ');
  t << '});' << "\n"
  t << "\n"
  t << '        colgoto.assign ({'
  t << lr.production.map{|e| e.lhs.to_s }.join(', ');
  t << '});' << "\n"
  t << "\n"
  t << '    }' << "\n"
  t
end

puts cxxtable(grammar_table)
