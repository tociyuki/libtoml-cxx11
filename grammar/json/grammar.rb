#!/usr/bin/env ruby

# Toy LALR(1) Parser https://github.com/tociyuki/rzubr-ruby
require 'rzubr'

def grammar_table
  rule = Rzubr::Rule

  # RFC 7159 The JavaScript Object Notation (JSON) Data Interchange Format
  value = rule.name(:value) \
    > rule[:SCALAR] \
    | rule[:STRING] \
    | rule['[', :array, ']'] \
    | rule['{', :table, '}'] \
    | rule['[', ']'] \
    | rule['{', '}']

  array = rule.name(:array) \
    > rule[:array, ',', :value] \
    | rule[:value]

  table = rule.name(:table) \
    > rule[:table, ',', :STRING, ':', :value] \
    | rule[:STRING, ':', :value]

  g = (value + array + table).start(:value)
  Rzubr::LALR1.new.rule(g)
end

def cxxtable(lr)
  token = {
    # nil, 'TOKEN_INVALID',
    :SCALAR   => 'TOKEN_SCALAR',
    :STRING   => 'TOKEN_STRING',
    '{' => 'TOKEN_LBRACE',
    '}' => 'TOKEN_RBRACE',
    '[' => 'TOKEN_LBRACKET',
    ']' => 'TOKEN_RBRACKET',
    ':' => 'TOKEN_COLON',
    ',' => 'TOKEN_COMMA',
    Rzubr::ENDMARK => 'TOKEN_ENDMARK',
  }
  pnum = {}.tap{|h| lr.production.each_with_index{|e,x| h[e] = 256 - x - 2 } }
  colgoto = lr.production.map{|e| e.lhs }.uniq
  t = ''
  t << '// autogenerated by rzubr' << "\n"
  lr.production.each_with_index do |e, x|
    rhs = e.rhs.map {|s| Symbol === s ? s.to_s : s.inspect }.join(' ')
    t << "//case %2d: // %s: %s" % [x, e.lhs.to_s, rhs] << "\n"
  end
  t << "\n"
  t << '    void' << "\n"
  t << '    define_state ()' << "\n"
  t << '    {' << "\n"
  t << '        enum { ';
  t << '%s = %d, ' % [colgoto[0].to_s, token.size + 1]
  t << colgoto[1 .. -1].map{|x| x.to_s }.join(', ')
  t << ' };' << "\n"
  t << "\n"
  lr.state.term.each_index do |state_p|
    lr.action[state_p].each_pair do |s, x|
      name = token[s] || 'TOKEN_INVALID'
      case x
      when Integer
        t << '        to (%d, %s, %d);' % [state_p + 1, name, x + 1] << "\n"
      when :accept
        t << '        to (%d, %s, 255);' % [state_p + 1, name] << "\n"
      when Rzubr::Production
        t << '        to (%d, %s, %d);' % [state_p + 1, name, pnum[x]] << "\n"
      end
    end
    lr.goto[state_p].each_pair do |s, x|
      t <<   '        to (%d, %s, %d);' % [state_p + 1, s.to_s, x + 1] << "\n"
    end
    t << "\n"
  end
  t << '        nrhs.assign ({'
  t << lr.production.map{|e| e.rhs.size }.join(', ');
  t << '});' << "\n"
  t << "\n"
  t << '        colgoto.assign ({'
  t << lr.production.map{|e| e.lhs.to_s }.join(', ');
  t << '});' << "\n"
  t << "\n"
  t << '    }' << "\n"
  t
end

puts cxxtable(grammar_table)
